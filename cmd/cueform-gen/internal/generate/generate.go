package generate

import (
	"fmt"
	"strings"

	"cuelang.org/go/cue/ast"
	"cuelang.org/go/cue/token"
	tfjson "github.com/hashicorp/terraform-json"
	"github.com/jcrqr/cueform/cmd/cueform-gen/internal/config"
	"github.com/zclconf/go-cty/cty"
)

func Transform(p *config.Provider, schema *tfjson.ProviderSchema) (*ast.File, error) {
	var resources []any
	for name, schema := range schema.ResourceSchemas {
		resources = append(resources, makeSchema(name, schema))
	}

	var dataSources []any
	for name, schema := range schema.DataSourceSchemas {
		dataSources = append(dataSources, makeSchema(name, schema))
	}

	f := &ast.File{
		Filename: p.Filename,
		Decls: []ast.Decl{
			&ast.CommentGroup{List: []*ast.Comment{
				{Text: fmt.Sprintf("// Code generated by cueform-gen; DO NOT EDIT.\n")},
			}},
			&ast.Package{Name: ast.NewIdent(p.Name)},
			&ast.Field{
				Label: ast.NewIdent("#metadata"),
				Value: ast.NewStruct(
					&ast.Field{Label: ast.NewIdent("name"), Value: ast.NewString(p.Name)},
					&ast.Field{Label: ast.NewIdent("source"), Value: ast.NewString(p.Source)},
					&ast.Field{Label: ast.NewIdent("version"), Value: ast.NewString(p.Version)},
				),
			},
			makeSchemaBlock("#provider", schema.ConfigSchema.Block),
			&ast.Field{
				Label: ast.NewIdent("#resources"),
				Value: ast.NewStruct(resources...),
			},
			&ast.Field{
				Label: ast.NewIdent("#data_sources"),
				Value: ast.NewStruct(dataSources...),
			},
		},
	}

	return f, nil
}

func parseRegistryUri(uri string) (string, string, error) {
	parts := strings.Split(uri, "/")
	if len(parts) < 3 {
		return "", "", fmt.Errorf("invalid provider URI: %s", uri)
	}
	return parts[1] + "/" + parts[2], parts[2], nil
}

func makeSchema(name string, schema *tfjson.Schema) *ast.Field {
	return makeSchemaBlock(name, schema.Block)
}

func makeSchemaBlock(name string, block *tfjson.SchemaBlock) *ast.Field {
	field := &ast.Field{
		Label: ast.NewIdent(fmt.Sprintf("%s", name)),
	}

	addDescription(field, block.Description)

	attrs := []any{
		&ast.Field{Label: ast.NewIdent("#name"), Value: ast.NewString(name)},
	}
	for name, attr := range block.Attributes {
		attrs = append(attrs, makeAttribute(name, attr))
	}
	for name, block := range block.NestedBlocks {
		attrs = append(attrs, makeSchemaBlockType(name, block))
	}

	field.Value = ast.NewStruct(attrs...)
	return field
}

func makeSchemaBlockType(name string, block *tfjson.SchemaBlockType) *ast.Field {
	field := makeSchemaBlock(name, block.Block)

	field.Attrs = append(field.Attrs, &ast.Attribute{
		Text: fmt.Sprintf(
			"@block(mode=%s, min=%d, max=%d)",
			block.NestingMode, block.MinItems, block.MaxItems,
		),
	})

	switch block.NestingMode {
	case tfjson.SchemaNestingModeSingle:
	case tfjson.SchemaNestingModeGroup:
	case tfjson.SchemaNestingModeSet:
		field.Value = ast.NewList(&ast.Ellipsis{Type: field.Value})
	case tfjson.SchemaNestingModeList:
		field.Value = ast.NewList(&ast.Ellipsis{Type: field.Value})
	case tfjson.SchemaNestingModeMap:
		field.Value = ast.NewStruct(&ast.Field{Label: ast.NewList(ast.NewIdent("string")), Value: field.Value})
	}

	return field
}

func makeAttribute(name string, attr *tfjson.SchemaAttribute) *ast.Field {
	field := &ast.Field{
		Label:      ast.NewIdent(name),
		Constraint: token.OPTION,
	}

	addDescription(field, attr.Description)

	if attr.Required {
		field.Constraint = token.NOT
	}

	if attr.Computed {
		field.Attrs = append(field.Attrs, &ast.Attribute{Text: "@computed()"})
	}

	if attr.Sensitive {
		field.Attrs = append(field.Attrs, &ast.Attribute{Text: "@sensitive()"})
	}

	if attr.Deprecated {
		field.Attrs = append(field.Attrs, &ast.Attribute{Text: "@deprecated()"})
	}

	if attr.AttributeNestedType != nil {
		field.Value = attrNestedType(attr.AttributeNestedType)
	} else {
		field.Value = attrType(&attr.AttributeType)
	}

	return field
}

func attrType(t *cty.Type) ast.Expr {
	if t.IsPrimitiveType() {
		return ast.NewIdent(t.FriendlyName())
	}
	if t := t.MapElementType(); t != nil {
		return attrMapType(t)
	}
	if t := t.SetElementType(); t != nil {
		return attrSetType(t)
	}
	if t := t.ListElementType(); t != nil {
		return attrListType(t)
	}
	if t.IsObjectType() {
		return attrObjectType(t)
	}

	return ast.NewIdent("_")
}

func attrMapType(t *cty.Type) ast.Expr {
	return ast.NewStruct(&ast.Field{
		Label: ast.NewList(ast.NewIdent("string")),
		Value: attrType(t),
	})
}

func attrSetType(t *cty.Type) ast.Expr {
	return ast.NewList(&ast.Ellipsis{Type: attrType(t)})
}

func attrListType(t *cty.Type) ast.Expr {
	return ast.NewList(&ast.Ellipsis{Type: attrType(t)})
}

func attrObjectType(t *cty.Type) ast.Expr {
	var fields []any
	for k, v := range t.AttributeTypes() {
		fields = append(fields, &ast.Field{
			Label: ast.NewIdent(k),
			Value: attrType(&v),
		})
	}
	return ast.NewStruct(fields...)
}

func attrNestedType(_ *tfjson.SchemaNestedAttributeType) ast.Expr {
	return ast.NewIdent("_")
}

func addDescription(field *ast.Field, desc string) {
	if desc == "" {
		return
	}

	cg := &ast.CommentGroup{}
	for _, line := range strings.Split(desc, "\n") {
		cg.List = append(cg.List, &ast.Comment{Text: fmt.Sprintf("// %s", line)})
	}

	field.AddComment(cg)
}
